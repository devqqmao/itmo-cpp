[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/70axqZT2)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=12816039&assignment_repo_type=AssignmentRepo)
# Домашнее задание 6

Разработайте новый класс строки. Ваша строка должна быть близкой по интерфейсу к строке `std::basic_string`, предлагаемой в библиотеке STL.

Основное отличие - **ленивое копирование**.

## О реализации

Наивная реализация `std::basic_string` строки предполагает, что каждый объект-строка единолично владеет своим буфером.

В стандартах C++ до версии C++11 не накладываются ограничения на реализацию `std::basic_string`,
поэтому в некоторых реализациях STL `std::basic_string` копируется лениво.

Для обеспечения более строгих гарантий производительности в многопоточных окружениях 
начиная с версии стандарта C++11 в реализации `std::basic_string` ленивое копирование фактически запрещено.

Такое архитектурное решение **имеет много плюсов**, однако есть и **существенный минус**:
копирование строки является достаточно дорогой операцией, поскольку требует выделение памяти под новый буфер.
Это, в частности, приводит к тому, что рекомендуемый способ передачи параметра объекта-строки в функцию - **по константной ссылке** или с помощью `std::string_view`, а не по значению.

Можно предложить небольшую модификацию, которая избавит нас от такой необходимости.
Она также позволяет уменьшить потребление памяти в случае, если в программе используются много копий одной исходной строки.

Для решения этой задачи достаточно сохранять в строке лишь ссылку на буфер и
обеспечить корректное совместное использование общего буфера между разными объектами-строками,
оперирующими в действительности одной и той же строкой. Например, средствами счетчика ссылок.

В случае же, если происходит обращение к модифицирующей операции над объектом-строкой,
а она разделяет свое владение буфером с другими объектами-строками,
необходимо выделить новый буфер и произвести модификацию именно его.

Наиболее нетривиальной становится реализация неконстантного оператора обращения по
индексу `[]`.
- **В случае чтения символа, строка не должна модифицироваться.**
- **Если же происходит изменение символа, строка должна модифицироваться согласно описанному выше правилу.**

## Требования к реализации

Ниже приводится список требований к интерфейсу класса, который является подмножеством интерфейса STL `std::basic_string`.

- Класс `lazy_basic_string` должен представлять собой **шаблонный класс от типа символа и класса свойств символов** - аналогично STL `std::basic_string`, но **без аллокатора**.
- **Класс свойств символов должен использоваться для всех операций с символами строки** 
(например, для копирования буфера символов необходимо использовать статический метод `copy()` класса свойств).
Интерфейс класса свойств символов должен соответствовать `std::char_traits`.
- Интерфейс `lazy_basic_string` должен содержать следующие методы, аналогичные методам `std::basic_string`:
  - **Типы**: все, кроме аллокатора и итераторов.
  - **Конструкторы**: от другой ленивой строки; без параметров; **неявный (!)** от C-строки; заполнение заданным количеством указанных символов.
  - **Операторы**:
    - присваивания;
    - сложение `+=` и `+` (для ленивой строки, C-строки, символа);
    - `[]` обращение по индексу должно быть представлено двумя операторами -
    константным и неконстантным (второй не должен изменять строку, если действительного изменения символа не произошло).
    **Обратите внимание, что тип прокси объекта для реализации этой задачи не должен быть доступен клиентам вашего класса ленивой строки.**
    - сравнения ленивых строк (достаточно реализовать операторы `==`, `!=`, `<`). Как между собой, так и с С-строками.
  - **Методы** `swap()`, `clear()`, `size()`, `empty()`, `c_str()` аналогичные методам `std::basic_string`. Функция `swap()` должна быть как внутренней, так и внешней.
  - **Метод** `size()` должен иметь временную сложность `O(1)`.
- Все операции над строкой должны удовлетворять **строгой гарантии безопасности исключений**. Стоит заметить, что для этого не нужно использовать `try`/`catch`.
- **Определите синонимы вашего класса** для работы с типами `char` и `wchar_t` соответственно `lazy_string` и `lazy_wstring`.
- Обеспечьте реализацию строки `lazy_istring`, **нечувствительной к регистру при сравнении** на основе вашей реализации `lazy_basic_string`.
- Постарайтесь **минимизировать количество выделений динамической памяти**. Например, если вы используете `std::shared_ptr`, создавайте его с помощью `std::make_shared`.
- Постарайтесь **избежать дублирования хранимых данных**. Например, размер общего буфера лучше хранить в общих данных вместе с буфером, а не в каждом экземпляре строки (если вы не реализуете описанную ниже **Small Object Optimization**).
- В данной задаче **запрещено использовать готовые классы строк** (в том числе, `std::basic_string`). Остальные примитивы библиотеки STL можно и рекомендуется использовать 
  Учтите, что примитивы STL или их обычное использование могут не удовлетворять описанным требованиям данной задачи. Например, если вы используете `std::vector` для хранения буфера символов, то вы не можете использовать конструкторы копирования или операции меняющие размеры вектора, т.к. в данных операциях происходит копирование символов, которое вы обязаны делать с помощью класса свойств символов (`char traits`).
- В реализации не должно быть утечек памяти.

## Дополнительное задание

Реализуйте **Small Object Optimization** (также эту оптимизацию называют **Small Buffer Optimization** или **Small String Optimization**).

В наивной реализации класса строки буфер символов хранится в выделяемой динамической памяти, а сам класс строки содержит указатель на этот буфер символов и длину хранимой строки.
Таким образом класс строки имеет `8 + 8 = 16` байт накладных расходов (на 64-битной платформе, где размер указателя и размер `size_t` - `8` байт).
Для коротких строк, длиной менее `8` байт, данные накладные расходы могут оказаться существенными.

В **Small Object Optimization** предлагается следующая идея:
для коротких строк хранить буфер символов не в динамически выделяемой памяти, а непосредственно в поле класса строки, отведённого для хранения указателя на буфер.
Для этого в классе строки вместо указателя на буфер, используется `union` указателя на буфер и `char[8]`:
- если хранимая строка короче 8 байт, то `union` будет использоваться как поле типа `char[8]`,
- если длиннее - то как указатель.

## Структура проекта

Решение необходимо оформить **в виде библиотеки, состоящей из одного заголовочного файла**.
Заголовочный файл должен называться `lazy_string.hpp`.

- Класс `lazy_basic_string` и связанные определения типов должны быть реализованы в пространстве имен `std_utils`.
- Все необходимые вспомогательные классы и функции должны быть либо скрыты внутри класса `lazy_basic_string`, либо находиться в пространстве имён `std_utils::details`.
- Допускается нахождение в репозитории рядом с файлом `lazy_string.hpp` вспомогательных файлов, которые вы можете использовать для тестирования вашей библиотеки, они не будут участвовать в проверке.

### Hint

Для сборки приложения из консоли следуют выполнить следующий набор инструкций:
```shell
mkdir build; cd build;
cmake .. -G <GeneratorName>
cmake --build .
```

Для запуска автотестов:
```shell
ctest . # or use -R <test-name> to run specific test
```
